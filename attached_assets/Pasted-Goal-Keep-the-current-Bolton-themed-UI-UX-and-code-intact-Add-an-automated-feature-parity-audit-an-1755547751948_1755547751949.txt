Goal: Keep the current Bolton-themed UI/UX and code intact. Add an automated feature-parity audit and implement any missing features so the app works like Ironclad-style repository CLM plus common Mochadocs-like flows (templates/clauses/obligations). Do not copy proprietary code—replicate behaviors/patterns only. Produce a full test suite that walks every button and key flow and a final parity report.

0) Guardrails (don’t break existing app)

Do not remove/rename existing files, exports, routes, or design tokens.

Preserve the current Bolton theme (buttons, tokens, CSS vars) and the Button component.

Add/extend only. Use feature flags in src/config.ts:

export const IRONCLAD_MODE = true;          // enables advanced repo UX
export const MOCHADOCS_MODE = true;         // enables templates/clauses/obligations flows
export const TEST_MODE = true;              // makes e2e safe (uses mocks)


All new behavior must be gated by these flags; with flags off, the app should behave exactly as now.

1) Define the target behaviors (parity checklist)

Create parity/targets.yml describing the behaviors to match (no vendor code):

Repository (Ironclad-like):

Filter chips (multi-select): Status, Type, Counterparty, People, Date

Saved views (star/rename/delete) persisted in localStorage

List with bulk select, sticky bulk bar: Change status, Assign to me, Export CSV

Right-side details drawer with deep-link ?contractId=…

Search (debounced), sort (Updated/Title/Status), pagination (25/50/100)

Keyboard shortcuts: / focus search, n new, esc close drawer, shift+a select all

Role-based actions (viewer/editor/admin)

Mochadocs-like essentials (generic CLM patterns):

Templates page: create/edit contract templates, insert clause library items

Clause library: tags, search, insert into template or contract

Obligations tracker: key dates, owners, reminders; show on dashboard timeline

Attachments on contracts; drag-drop (mocked)

Audit log per contract (activity feed)

2) Service layer (non-breaking adapters)

Keep/extend the existing RepositoryService pattern. Create:

src/services/repository.mock.ts (contracts in-memory + latency)

src/services/templates.mock.ts, src/services/clauses.mock.ts, src/services/obligations.mock.ts

Add getService() factory in src/services/index.ts returning mocks when TEST_MODE true. All components call services only—no direct fetch.

3) Implement missing features safely

If a target in parity/targets.yml is missing, implement it using existing components (Button, Chip, Badge) and styles.

New pages: /templates, /clauses, /obligations. Hook into top tabs and sidebar counts.

Add right-side DetailsDrawer (portal) for contracts; keep URL in sync.

Add Saved Views (localStorage key bolton:views:v1).

Add Export CSV (client-generated from visible rows).

Add New Contract Wizard (3 steps: Basics → Counterparty → Attachments).

4) Automated gap checker

Create scripts/gap-audit.ts:

Loads parity/targets.yml.

Statically scans src/ for selectors/components/exports that satisfy each target (e.g., presence of SavedViewsStore, DetailsDrawer, routes).

Runs a headless render (Vitest + JSDOM) of key pages to assert essential UI nodes exist (chips, bulk bar, drawer, wizard).

Outputs parity/parity-report.md with Present / Missing / Partially Met table and TODOs per missing item.

5) Tests that walk every function and button

Unit/Integration (Vitest + RTL)

tests/ui/buttons-all.spec.tsx: render each page; getAllByRole('button'); for each: is visible, clickable, no console errors.

tests/repository.spec.tsx: filters, saved views, bulk actions (optimistic update + rollback), drawer deep-link, search/sort/pagination.

tests/templates_clauses.spec.tsx: create template, insert clause, save; search clauses.

tests/obligations.spec.tsx: create obligation, reminder due, appears on dashboard timeline.

Coverage threshold: 90% lines/branches.

E2E (Playwright) with TEST_MODE=true

e2e/happy-path.spec.ts:

Open /contracts → search, filter, save view.

Open a row → drawer → edit status → close with Esc.

Select multiple → bulk “Assign to me” and “Export CSV”.

Start “New Contract” wizard → complete → lands in drawer.

Go to /templates → new template → insert clause → save.

Go to /obligations → create obligation → confirm on dashboard.

Assert no uncaught exceptions, no HTTP 4xx/5xx (mocks intercept).

Run basic a11y check with @axe-core/playwright on each main page.

6) Tooling & scripts

Add npm scripts:

"test": "vitest run --coverage",

"e2e": "playwright test",

"gap:audit": "ts-node scripts/gap-audit.ts",

"verify:all": "npm run gap:audit && npm run test && npm run e2e".

7) Acceptance criteria (must pass before you finish)

With flags off → app behaves exactly as now.

With flags on → all targets in parity/targets.yml are Present; if any Partial, implement until Present.

npm run verify:all passes (coverage ≥ 90%).

Deliverables:

parity/parity-report.md (what was missing, what was added),

full test suites,

updated README with flags, services, and how to switch to real APIs.

8) Finish

Implement, refactor minimally, and commit.

Run npm run verify:all.

Show me screenshots/GIFs of: repository with chips & bulk bar, details drawer, wizard, templates/clauses, obligations timeline, and the final parity-report.md.